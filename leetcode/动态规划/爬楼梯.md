# 70. [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/description/)

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。

**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

**示例 2：**

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

## 解答思路

首先要明白这和🐸跳台阶一样,同样是动态规划问题.解决动态规划问题一般遵循以下五个步骤

- 判题题意是否为找出一个问题的最优解 
- 从上往下分析问题,将大问题分解为子问题,子问题中还有更小的子问题 
- 从下往上分析问题 ,找出这些问题之间的关联,即写出状态转移方程
- 讨论底层的边界问题 
- 解决问题（通常使用数组进行迭代求出最优解）

我们已经确定该问题属于动态规划,接下来需要从上往下分析问题.假设要爬到第5阶,这时候又分为两种情况:

- 最后爬了1阶,此时问题变成"爬上第4阶有多少中爬法"
- 最后爬了2阶,此时问题变成"爬上第3阶有多少中爬法"

设函数f(n)表示爬上第n阶的方法,根据上述说明那么`f(5)=f(4)+f(3)`,依次类推,`f(4)=f(3)+f(2)`.

现在我们从下往上分析问题,可知状态转移方程为`f(n)=f(n-1)+f(n-2)`

现在来讨论底层边界问题:

- 当n=1时,只有一种方式,即爬1阶
- 当n=2时,有两种方式,即一次爬2阶和两次分别爬1阶

当n=3时,其满足状态状态转移方程`f(3)=f(2)+f(1)`,此时我们既可以解决问题了,为了方便我们采用自下而上的写法,即迭代过程:

```java
class Solution {
    public int climbStairs(int n) {
        if(n==0){
            return 0;
        }
        if(n==1){
            return 1;
        }
        if(n==2){
            return 2;
        }
        int[] nums=new int[n+1];
        nums[0]=0;
        nums[1]=1;
        nums[2]=2;
        for(int i=3;i<=n;i++){
            nums[i]=nums[i-1]+nums[i-2];
        }
        return nums[n];
    }
}
```

