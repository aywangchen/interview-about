# 网络协议

## 简述网络模型？七层和四层联系与区别？

七层:应用层,表示层,会话层,运输层,网络层,数据链路层,物理层

TCP/IP四层:应用层,传输层,网络层,网络接口层

## 简单说一说TCP报文头?

报文段分为头部和数据两个部分,其中头部包含了此报文段的一些基本信息,其格式如下:

![image-20181024193354277](https://i.imgur.com/7JvyV9m.png)

## 简单说说TCP中的拥塞控制算法?

拥塞控制就是防止过多的数据注入网络中,这样可以使网络中的路由器或链路不致过载.拥塞控制是一个全局性的过程,和流量控制不同,流量控制指点对点通信量的控制.TCP的拥塞控制主要涉及四个过程:慢开始,拥塞避免,快重传和快恢复.

### 慢开始和拥塞避免

慢开始算法的思路就是,不要一开始就发送大量的数据,先探测一下网络的拥塞程度,也就是说由小到大逐渐增加拥塞窗口的大小.

发送方会维持一个拥塞窗口,刚开始的拥塞窗口和发送窗口相等,一般开始均设置1,然后我们每收到一个确认,就让拥塞窗口大小变为原来的2倍,接着发送分组也是原来的两倍,以此类推,当窗口值等于16(慢开始门限),然后我们开始采用拥塞避免算法,即加法增大的策略:不在以2倍的方式增加,而是转变为每次加1的方式.

无论是在**慢开始阶段**还是在**拥塞避免阶段**,只要发送方判断网络出现拥塞(其根据就是没有收到确认,虽然没有收到确认可能是其他原因的分组丢失,但是因为无法判定,所以都当做拥塞来处理),就把慢开始门限设置为出现拥塞时的发送窗口大小的一半.然后把拥塞窗口设置为1,执行慢开始算法,如下图所示:

![image-20181202184209983](https://i.imgur.com/uDru5x1.png)

### 快重传

快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)而不要等到自己发送数据时捎带确认.快重传算法规定:发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段,而不必继续等待设置的重传计时器时间到期,如图:

![image-20181202185013864](https://i.imgur.com/vo7DaXb.png)

### 快恢复

当发送发连续接收到三个确认时,就执行乘法减小算法,把慢启动开始门限减半,但是接下来并不执行慢开始算法,而是将cwnd设置为ssthresh的大小,然后执行拥塞避免算法.如下图:

![image-20181202185402586](https://i.imgur.com/tCFyMaB.png)

## TCP和UDP异同？

- TCP协议是一种可靠的,面向连接的协议:保证通信主机之间有可靠的字节流传输,完成流量控制功能,协调收发双方的发送与接收速度,达到正确传输的目的

- UDP是一种不可靠,无连接的协议:其特点是协议简单,额外开销小,效率较高,但是不能保证传输是否正确

## 你哪些协议是在TCP或UDP基础上开发的?

基于TCP协议的有:

- HTTP协议:从Web服务器传输超文本到本地浏览器的传送协议,默认使用80端口.
- FTP:文件传输协议,默认使用21端口.
- SMTP:简单邮件传送协议,用于发送邮件,默认使用25号端口.
- POP3:和SMTP对应,POP3用于接收邮件,默认使用110端口
- Telnet:一种用于远程登陆的端口,用户可以以自己的身份远程连接到计算机上,通过这种端口可以提供一种基于DOS模式下的通信服务,默认使用23端口

基于UDP协议的有:

- DNS:域名解析服务,将域名地址转换为IP地址,默认使用53号端口.
- TFTP(Trival File Transfer Protocal):简单文件传输协议,默认使用69号端口.
- SNMP:简单网络管理协议,默认使用161号端口,是用来管理网络设备的.

## 为什么说TCP是可靠的？或者说TCP是如何保证可靠传输的?

- 确认和重传: 接收方收到报文就会确认,发送方发送一段时间后没有收到确认就会重传
- 数据校验: TCP报文头有校验和,用于校验报文是否损坏
- 数据合理分片和排序: TCP会按最大传输单元(MTU)合理分片,接收方会缓存未按序到达的数据,重新排序后交给应用层
- 流量控制: 当接收方来不及处理发送方的数据,能通过滑动窗口,提示发送方降低发送的速率,防止包丢失.
- 拥塞控制: 当网络拥塞时,通过拥塞窗口,减少数据的发送,防止包丢失

## 简述三次握手和四次握手的过程

三次握手建立链接的过程如下:

在建立TCP连接过程中，需要客户端和服务端总共发送3个报文段以确认连接的建立,其过程如下:

![image-20181024193518005](https://i.imgur.com/dtQHGLZ.png)

1. 第一次握手:Client将标志位SYN置为1,随机产生一个序号(seq)J,并将该数据包发送给Server,Client进入SYN_SENT状态,等待Server确认.
2. 第二次握手:Server接收到报文段,生成一个新的报文段发送给Client,新报文段中:SYN = 1,ACK = 1,序号(seq)= J+1,确认序号(ack) = k(k为随机生成);Server进入SYN_RCVD状态
3. 第三次握手:Client收到报文段,对报文段进行校验(ACK是否为1,ack是否为J+1),校验通过生成一个新的报文段发送给Server:ACK = 1,ack = K+1,此时Client进入ESTABLISHED状态.Server对接收到的报文段校验,校验通过进入ESTABLISHED状态.

四次握手断开链接的过程如下:

![image-20181024193918166](https://i.imgur.com/Z0l2JnO.png)

由于TCP连接时全双工的,因此每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此

## 说说HTTP 1.0,HTTP 1.1与HTTP 2.0的区别?

1.1相对于1.0：

- 支持长连接
- 增加了host域
- 增加了Range头域，支持断点续传

2.0 相对于1.x：

- 支持多路复用
- 采用二进制分帧
- 首部压缩
- 服务器推送

## 如何提高HTTP传输中数据的安全性？如果让你来设计，你会怎么设计安全的HTTP协议？

## 了解WebSocket技术么？讲讲他与HTTP协议之间的联系？

## 简述SYPD协议是如何提高速度的？

## HTTPS的好处是什么？简述其实现原理呢？

HTTPS是在SSL/TLS基础上发展而来的通讯安全的HTTP协议.其核心是借助非对称加密和对称加密来保证通信安全.其主要流程为:

- 服务端首先会生成非对称加密需要的公钥和私钥信息,
- 客户端请求服务端,服务端将公钥信息发送给客户端
- 客户端对公钥信息校验,校验通过后生成用于此次通信的随机对称密钥,并使用服务端公钥进行加密,最终发送给服务端
- 服务端对使用私钥解密,得到客户端的随机对称密钥,后续过程服务端和客户端就使用该对称密钥进行通信(实际上该密钥并不是最终用于通信所使用的密钥,具体可见后面SSL握手阶段的说明).

![image-20181121155834797](https://ws1.sinaimg.cn/large/006tNbRwly1fxfqowhthvj30zn0u0act.jpg)

在这上述过程中,如何保证服务端公钥信息在发送到客户端的过程中不被篡改呢?这里采用将公钥信息存储到数字证书中,并确保数字证书由公认的机构签发,客户端在接受到数字证书后,会和内置的根证书信息进行校验,校验通过后即可说明该数字证书是合法的.

实际上整个HTTPS的通信过程更加复杂一些,这里只是大概描述了其原理.

## 简述SSL安全机制

SSL的安全机制主要包含以下三个方面:

- 身份验证机制: 基于证书利用数字签名,对服务端和客户端进行身份验证(客户端身份验证可选)
- 数据安全传输: 利用对称加密算法对传输内容进行加密
- 消息完整性校验: 消息传输过程中使用MAC算法来验证消息的完整性

## SSL/TLS是怎么进行加密握手的?

在握手阶段主要涉及四次通信过程:

1. 客户端发送请求(Client Hello): 包含客户端支持协议版本号,比如TLS1.0;一个客户端生成的随机数(client-random),稍后用于生成对话密钥;客户端支持的加密方法,比如RSA;客户端支持的压缩方法

2. 服务端响应(Server Hello): 确认通信使用协议版本,比如TLS1.0;一个服务端生成的随机数(server-random),稍后用于生成对话密钥;确认使用的加密方法,如RAS;服务器证书.(如果服务端需要确认客户端身份,会要求客户端提供客户端证书,比如金融机构只允许自己认证的客户端连接自己的网络,就会想客户端提供USB密钥,里边包含的就是一张客户端证书)

3. 客户端响应: 客户端收到服务端响应后,首先验证服务端证书,如果该证书不是可信机构颁发的或者证书信息有误,比如证书过期,就会向用户显示警告,用用户选择是否要继续通信.如果证书没有问题,客户端就从证书中提取公钥信息,然后向服务端发送以下信息:

   - 客户端生成一个新的随机数(pre-master-secret),并用公钥加密,防止被窃听

   - 编码改变通知: 表示随后的信息都将用双方商定的加密方法和密钥发送

   - 客户端握手通知结束: 表示客户端握手阶段结束,该项也是前面所有发送内容的hash值,用于服务端进行校验

     > 客户端和服务端分别持有了三个随机数,后面双方事先商定的加密算法,各自生成本次会话的一把会话密钥(session key)

4. 服务端响应: 服务器收到客户端的第三个随机数pre-master-key之后,计算生成本次会话所用的会话密钥,然后向客户端最后发送下面信息:

   - 编码通知改变: 表示随后的信息都将用双方商店的加密方法和密钥发送
   - 服务端握手通知结束: 表示服务器的握手阶段已经结束,该项同时也是前面发送的所有内容的hash值,用来供客户端校验

   至此,整个握手阶段结束,接下来,客户端与服务端进入加密通信阶段,该阶段使用的是普通的HTTP协议,只不过都用用会话密钥进行了加密.

   ![image-20181121164240939](https://ws3.sinaimg.cn/large/006tNbRwly1fxfrysbmbxj31eu0u07wh.jpg)

## SSL/TLS 中最终为什么要使用基于对称加密的对称密钥?而不是全程非对称加密?

主要是从效率上考虑,非对称加密安全性较高,但效率较差,在加密大量数据时,耗时更久.在每次会话过程中,客户端和服务器端都生成一个会话密钥(session key),它是基于是对称加密,运算速度非常快,而服务器公钥只用于握手阶段,因此能够有效的提高通信效率.

## SSL/TLS 握手过程为什么要使用三个随机数来生成最终的会话密钥?

其主要原因在于SSL不信任每台主机能够产生完全随机的随机数,如果随机数不随机,pre-master-key可能会被猜解出来.因此通过引入三个随机数保证最终的会话密钥不容易被猜出.

## HTTP协议的格式是怎么样的?

这要分两点来描述:请求协议和响应协议.

对于请求协议而言,其格式如下

| 部分     | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| 请求行   | 用来说明请求类型,要访问的资源以及所使用的HTTP版本:请求方法,请求URL及HTTP版本 |
| 请求头   | 用来说明服务器要使用的附加信息.请求头(request header) ;普通头(general header) ;实体头(entity header) |
|  |请求头部后面的空行是必须的|
| 请求数据 | 通常来说,由于GET请求往往不包含内容实体,因此也不会有实体头.第三部分内容只在POST请求中存在,因为GET请求并不包含任何实体 |

如下所示:

```http
POST / HTTP1.1
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive

name=Professional%20Ajax&publisher=Wiley
```

对于响应协议而言,其格式如下:

| 部分     | 含义                                       |
| -------- | ------------------------------------------ |
| 状态行   | 由HTTP协议版本号,状态码,状态消息三部分组成 |
| 响应头   | 用来说明客户端要使用的一些附加信息         |
|          | 消息报头后面的空行是必须的                 |
| 响应正文 | 服务器返回给客户端的文本信息               |



## HTTP协议有哪些方法?

常用的请求有:get,post,update,delete,head,options.

- GET:请求读取由URL所标志的数据
- POST:给服务器添加或者更新数据 
- PUT:在给定的URL下存储一个文档 
- DELETE:删除给定的URL所标志的资源 
- OPTIONS:服务器针对特定资源所支持的HTTP请求方法 
- HEAD:向服务器索要与GET请求相一致的响应,只不过响应体将不会被返回.这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息

## HTTP中POST和GET请求有什么区别?

- GET是将请求参数加到URL中,POST是将请求数据放在请求体中.(需要注意的是在HTTP规范并未规定GET不能发送body数据,比如在OkHttpClient中发送带body的GET请求会报错,但AsyncHttpClient可以发送,但目前大多数工具被设计为不支持在GET请求中发送body)
- GET传送的数据量较小,一般是不能超过1024字节,POST传送的数据量较大,默认为不受限制。
- GET在浏览器回退时是无害的,而POST会再次提交请求.
- GET请求会被浏览器主动缓存,而POST不会,除非手动设置.
- GET请求只接受ASCII字符的参数,而POST请求没有限制.

从TCP协议的角度来看,两者最大的区别在于GET产生一个TCP包,而POST产生两个TCP包.对于GET请求,浏览器会把http header和data一起发出去,而对于POST,浏览器先发送header,等待服务器响应100状态码后,浏览器再发送data.

## 简述一次HTTP请求的过程?

- 客户端浏览器请求DNS服务器解析域名www.baidu.com 对应的IP地址，然后通过这个IP地址和默认端口80，和服务器建立TCP连接，连接建立之后通过TCP将HTTP会话封装成数据包。
- 在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口（如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口）然后使用IP层的IP地址查找目的端。
- 在客户端的网络层，通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，主要是通过查找路由表来决定通过哪个路径到达服务器。
- 在客户端的链路层，数据包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP（地址解析协议：将ip地址解析成物理地址）的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。

## HTTP响应状态码?

- 1xx：指示信息,表示请求已接收,继续处理.
- 2xx：成功,表示请求已被成功接收,理解,接受
- 3xx：重定向,要完成请求必须进行更进一步的操作
- 4xx：客户端错误,请求有语法错误或请求无法实现
- 5xx：服务器端错误,服务器未能实现合法的请求

常见的状态码有以下几种:

- 200 OK : 客户端请求成功
- 400 Bad Request : 客户端请求有语法错误,不能被服务器所理解
- 401 Unauthorized : 请求未经授权,这个状态代码必须和WWW-Authenticate一起使用 
- 403 Forbidden : 服务器收到请求,但是拒绝提供服务
- 404 Not Found : 请求资源不存在,eg: 输入了错误的URL
- 500 Internal Server Error  : 服务器发生不可预期的错误
- 503 Server Unavailable : 服务器当前不能处理客户端的请求,一段时间后可能恢复正常

# 加密解密

## 简述编码算法?
常见的编码算法主要由两种:

- Hex: 将二进制数据按16进制转换为字符串
- Base64: 用64个可见字符来表示任意二进制数据的方法

Hex和Base64的主要区别在于Base64将3个字节转换为4个字符,而Hex将3个字节转换为6个字节.

## 简述Base64原理

Base64首先定义一个可见字符的索引表,按照规定,字符选用了`A-Z、a-z、0-9、+、/`这64个字符.

- 接下来首先将待转换的字符串每三个化为一组,由于每个字符占一个字节,因此一组三个字符占3个字节,共24位.

- 然后将上面的24个二进制位按照6位一组,划分为4组.

- 在每组前面填两个0,每组由6位变为8位一组,即由4组6位,变成4组8位,共4字节.

- 然后将每个字节转为十进制,并从字符索引表中取出对应下标处的字符.

  字符索引表结构如下:
  0	A		16	Q		32	g		48	w
  1	B		17	R		33	h		49	x
  2	C		18	S		34	i		50	y
  3	D		19	T		35	j		51	z
  4	E		20	U		36	k		52	0
  5	F		21	V		37	l		53	1
  6	G		22	W		38	m		54	2
  7	H		23	X		39	n		55	3
  8	I		24	Y		40	o		56	4
  9	J		25	Z		41	p		57	5
  10	K		26	a		42	q		58	6
  11	L		27	b		43	r		59	7
  12	M		28	c		44	s		60	8
  13	N		29	d		45	t		61	9
  14	O		30	e		46	u		62	+
  15	P		31	f		47	v		63	/

假设我们要将abc进行编码,根据上述流程,其变化如下:

字符:		a			  b			 c

ASCII:		97			  98			 99	

8bit:		01100001	  01100010	 01100011

6bit:		011000	010110	001001	100011

高位补00:	==00==011000	 ==00==010110	==00==001001	==00==100011

十进制:		24			22			9			35

对应索引表:	Y			W			J			j

因此对abc编码之后的结果为`YWJj`.在转换过程中,如果到最后发现最后字符不够3个情况,那么此时可以在最后追加相应个数的`=`符号即可,补齐规则如下:

- 2个字节:2个字节共16个二进制位,按照规则进行分组,每6位一组,则第3组缺少2位,用0补齐后边,由于第4组完全没有数据则用`=`补上即可.

- 1个字节:1字节共8个二进制位,按照规则进行分组,每6个一组,则第2组缺少4位,用0补齐后边,由于后面两组没有对应数据,直接都用`=`补上即可.

以对A进行编码为例,其过程如下所示:

字符:		A			 

ASCII:		97			  	

8bit:		01000001	  

6bit:		010000		01==0000==(补齐4位)	

高位补00:	==00==010000	 ==00==010000	

十进制:		16			16						

对应索引表:	Q			Q			=			=



## 对称加密和非对称加密的区别?及常用的算法?

- 对称加密就是加密和解密数据都是使用同一个key,这方面的算法有DES.

- 非对称加密,加密和解密是使用不同的key,发送数据之前要先和服务端约定生成公钥和私钥,使用公钥加密的数据可以用私钥解密,反之.这方面的算法有RSA

ssh和ssl协议都是典型的非对称加密。

## 有哪些摘要算法?说说你常见的某个摘要算法?

摘要算法又称哈希算法,它表示输入任意长度的数据,输出固定长度的数据.相同的输入数据始终得到相同的输出,不同的输入数据尽量得到不同的输出,这个输出也称之为数据指纹.摘要算法主要用来校验数据的完整性.

目前摘要算法目前主要有三中实现:

- CRC(Cyclic Redundancy Check): 循环冗余校验码.
- MD(Message Digest): 消息摘要算法,主要有MD5,MD4,MD2,其安全强度逐渐降低,摘要长度都是128位.
- SHA(Secure Hash Algorithm): 安全哈希算法,主要由SHA-1,SHA-224,SHA-256,SHA-384,SHA-512,其中SHA-1摘要长度160位,SHA-256顾名思义生成256位的摘要.
- MAC(Message Authentication Code): 消息认证码,是一种带秘密密钥的Hash函数,主要有HMAC系列算法.HMAC主要是在MD和SHA基础上添加了密钥,比如HmacMD2,HmacMD4,HmacMD5是在MD基础上添加密钥而来,HmacSHA1,HmacSHA224,HmacSHA256,HmacSHA38主要是在SHA基础上添加密钥而来.

# 文件处理

## 常见的编码方式有哪些？

## utf-8编码中的中文站几个字节？int呢？

## 如何实现一个JSON解析器？

## 列出某个文件下所有的文件?

